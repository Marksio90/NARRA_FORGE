"""
PDF Exporter for NARRA_FORGE.
Converts narrative outputs to PDF format.
"""
from typing import Dict, Any, Optional, List
from datetime import datetime
from pathlib import Path
import io

try:
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import cm, inch
    from reportlab.lib.enums import TA_CENTER, TA_JUSTIFY
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, PageBreak
    from reportlab.platypus import Table, TableStyle
    from reportlab.lib import colors
    from reportlab.pdfgen import canvas
except ImportError:
    SimpleDocTemplate = None


class PdfExporter:
    """
    Exporter for PDF format.

    Features:
    - Title page with metadata
    - Table of contents (optional)
    - Chapters with formatting
    - Page numbers
    - Custom styling
    """

    def __init__(self):
        if SimpleDocTemplate is None:
            raise ImportError("reportlab is required for PDF export. Install: pip install reportlab")

    def export(
        self,
        narrative_data: Dict[str, Any],
        output_path: str,
        metadata: Optional[Dict[str, str]] = None,
        include_toc: bool = False
    ) -> str:
        """
        Export narrative to PDF format.

        Args:
            narrative_data: Complete narrative data with segments
            output_path: Path where to save the PDF file
            metadata: Optional metadata (title, author, description, etc.)
            include_toc: Whether to include table of contents

        Returns:
            Path to created PDF file
        """
        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Create PDF document
        doc = SimpleDocTemplate(
            str(output_path),
            pagesize=A4,
            leftMargin=2.5*cm,
            rightMargin=2.5*cm,
            topMargin=2.5*cm,
            bottomMargin=2.5*cm
        )

        # Prepare metadata
        book_metadata = self._prepare_metadata(narrative_data, metadata)

        # Set PDF metadata
        doc.title = book_metadata['title']
        doc.author = book_metadata['author']
        doc.subject = book_metadata.get('description', 'Narrative generated by NARRA_FORGE')

        # Create story (content)
        story = []

        # Add title page
        story.extend(self._create_title_page(book_metadata))

        # Add table of contents if requested
        if include_toc:
            segments = self._extract_segments(narrative_data)
            if segments:
                story.extend(self._create_toc(segments))

        # Add chapters
        story.extend(self._create_chapters(narrative_data))

        # Build PDF
        doc.build(story, onFirstPage=self._add_page_number, onLaterPages=self._add_page_number)

        return str(output_path)

    def _prepare_metadata(
        self,
        narrative_data: Dict[str, Any],
        custom_metadata: Optional[Dict[str, str]] = None
    ) -> Dict[str, str]:
        """Prepare book metadata."""
        metadata = {
            'title': 'Narracja bez tytułu',
            'author': 'NARRA_FORGE',
            'date': datetime.now().strftime('%Y-%m-%d'),
        }

        # Extract from narrative data
        if 'metadata' in narrative_data:
            meta = narrative_data['metadata']
            if 'brief' in meta and hasattr(meta['brief'], 'title'):
                metadata['title'] = meta['brief'].title or metadata['title']

        if 'output' in narrative_data and isinstance(narrative_data['output'], dict):
            if 'title' in narrative_data['output']:
                metadata['title'] = narrative_data['output']['title']

        # Apply custom metadata
        if custom_metadata:
            metadata.update(custom_metadata)

        # Add description from world if available
        if 'metadata' in narrative_data and 'world' in narrative_data['metadata']:
            world = narrative_data['metadata']['world']
            if hasattr(world, 'description'):
                metadata['description'] = world.description

        return metadata

    def _create_title_page(self, metadata: Dict[str, str]) -> List:
        """Create title page."""
        styles = getSampleStyleSheet()

        # Custom title style
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=36,
            alignment=TA_CENTER,
            spaceAfter=30,
            textColor=colors.HexColor('#2c3e50')
        )

        # Author style
        author_style = ParagraphStyle(
            'Author',
            parent=styles['Normal'],
            fontSize=18,
            alignment=TA_CENTER,
            spaceAfter=12,
            textColor=colors.HexColor('#34495e')
        )

        # Date style
        date_style = ParagraphStyle(
            'Date',
            parent=styles['Normal'],
            fontSize=12,
            alignment=TA_CENTER,
            textColor=colors.HexColor('#7f8c8d')
        )

        elements = []

        # Spacer to center vertically
        elements.append(Spacer(1, 8*cm))

        # Title
        elements.append(Paragraph(metadata['title'], title_style))
        elements.append(Spacer(1, 2*cm))

        # Author
        elements.append(Paragraph(metadata['author'], author_style))
        elements.append(Spacer(1, 1*cm))

        # Date
        elements.append(Paragraph(metadata['date'], date_style))

        # Description if available
        if 'description' in metadata:
            elements.append(Spacer(1, 2*cm))
            desc_style = ParagraphStyle(
                'Description',
                parent=styles['Normal'],
                fontSize=11,
                alignment=TA_CENTER,
                textColor=colors.HexColor('#7f8c8d'),
                leftIndent=2*cm,
                rightIndent=2*cm
            )
            elements.append(Paragraph(metadata['description'][:300], desc_style))

        elements.append(PageBreak())

        return elements

    def _create_toc(self, segments: List[Dict[str, Any]]) -> List:
        """Create table of contents."""
        styles = getSampleStyleSheet()

        toc_title_style = ParagraphStyle(
            'TOCTitle',
            parent=styles['Heading1'],
            fontSize=24,
            alignment=TA_CENTER,
            spaceAfter=30
        )

        elements = []
        elements.append(Paragraph("Spis treści", toc_title_style))
        elements.append(Spacer(1, 1*cm))

        # TOC entries
        for i, segment in enumerate(segments, 1):
            title = segment.get('title', f'Rozdział {i}')
            toc_entry = f"{i}. {title}"
            elements.append(Paragraph(toc_entry, styles['Normal']))
            elements.append(Spacer(1, 0.3*cm))

        elements.append(PageBreak())

        return elements

    def _create_chapters(self, narrative_data: Dict[str, Any]) -> List:
        """Create PDF chapters from narrative data."""
        styles = getSampleStyleSheet()

        # Custom chapter title style
        chapter_style = ParagraphStyle(
            'ChapterTitle',
            parent=styles['Heading1'],
            fontSize=24,
            alignment=TA_CENTER,
            spaceAfter=30,
            spaceBefore=20,
            textColor=colors.HexColor('#2c3e50')
        )

        # Body text style
        body_style = ParagraphStyle(
            'Body',
            parent=styles['Normal'],
            fontSize=12,
            alignment=TA_JUSTIFY,
            spaceAfter=14,
            leading=18,
            firstLineIndent=20
        )

        # Dialogue style
        dialogue_style = ParagraphStyle(
            'Dialogue',
            parent=body_style,
            leftIndent=1*cm,
            fontName='Times-Italic'
        )

        elements = []

        # Get segments
        segments = self._extract_segments(narrative_data)

        if not segments:
            # Fallback: single chapter with full output
            content = self._extract_full_text(narrative_data)
            elements.append(Paragraph("Narracja", chapter_style))
            elements.append(Spacer(1, 0.5*cm))

            # Add paragraphs
            paragraphs = content.split('\n\n')
            for para in paragraphs:
                para = para.strip()
                if para:
                    if para.startswith('—') or para.startswith('–') or para.startswith('-'):
                        elements.append(Paragraph(para, dialogue_style))
                    else:
                        elements.append(Paragraph(para, body_style))

            return elements

        # Create chapter for each segment
        for i, segment in enumerate(segments, 1):
            if i > 1:
                elements.append(PageBreak())

            chapter_title = segment.get('title', f'Rozdział {i}')
            chapter_content = segment.get('text', segment.get('content', ''))

            # Chapter title
            elements.append(Paragraph(chapter_title, chapter_style))
            elements.append(Spacer(1, 0.5*cm))

            # Chapter content
            paragraphs = chapter_content.split('\n\n')
            for para in paragraphs:
                para = para.strip()
                if para:
                    if para.startswith('—') or para.startswith('–') or para.startswith('-'):
                        elements.append(Paragraph(para, dialogue_style))
                    else:
                        elements.append(Paragraph(para, body_style))

        return elements

    def _extract_segments(self, narrative_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Extract narrative segments from data."""
        # Try different keys where segments might be stored
        if 'output' in narrative_data:
            output = narrative_data['output']

            if isinstance(output, dict):
                if 'segments' in output:
                    return output['segments']
                elif 'chapters' in output:
                    return output['chapters']
            elif isinstance(output, list):
                return output

        # Check in metadata
        if 'metadata' in narrative_data:
            if 'edited_segments' in narrative_data['metadata']:
                return narrative_data['metadata']['edited_segments']
            elif 'stylized_segments' in narrative_data['metadata']:
                return narrative_data['metadata']['stylized_segments']
            elif 'segments' in narrative_data['metadata']:
                return narrative_data['metadata']['segments']

        return []

    def _extract_full_text(self, narrative_data: Dict[str, Any]) -> str:
        """Extract full narrative text as fallback."""
        if 'output' in narrative_data:
            output = narrative_data['output']

            if isinstance(output, str):
                return output
            elif isinstance(output, dict):
                if 'text' in output:
                    return output['text']
                elif 'content' in output:
                    return output['content']

        return "Brak treści narracji."

    def _add_page_number(self, canvas_obj, doc):
        """Add page number to each page."""
        canvas_obj.saveState()
        canvas_obj.setFont('Times-Roman', 10)
        page_num = canvas_obj.getPageNumber()

        text = f"— {page_num} —"
        canvas_obj.drawCentredString(A4[0] / 2, 1.5*cm, text)

        canvas_obj.restoreState()
